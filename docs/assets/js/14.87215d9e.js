(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{462:function(e,t,n){"use strict";n.r(t);var s=n(42),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"modularizing-nginx-blocks-using-snippets"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#modularizing-nginx-blocks-using-snippets"}},[e._v("#")]),e._v(" Modularizing nginx blocks using snippets")]),e._v(" "),n("p",[e._v("Nginx configurations are much easier to write (in my honest opinion) as compared to apache because the of the structure being so similar to Objects but in cases where you have a complex logic in place that requires you to have really long lines of configuration code, it starts to become messy and really long which for me becomes a pain to read especially when im using an editor like VIM or nano. In such cases we can actually start making use of the "),n("code",[e._v("include")]),e._v("statement where in we can break the configurations into smaller reusable snippets.")]),e._v(" "),n("p",[e._v("So here is a real life scenario; at "),n("a",{attrs:{href:"http://bluewatertracks.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("BlueWaterTracks"),n("OutboundLink")],1),e._v(", we have a staging server that has serves 4 different applications; 2 Polymer applications and 2 api servers built on nodejs. Our staging config looked like the following")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('server {\n\tlisten 80 default_server;\n\tserver_name demo.example.com;\n\treturn 301 https://demo.example.com$request_uri;\n}\nserver {\n\tlisten 80 default_server;\n\tserver_name api.demo.example.com;\n\treturn 301 https://api.demo.example.com$request_uri;\n}\nserver {\n\tlisten 443 ssl http2;\n\troot /home/grant/bluewatertracks/current/client/build/bundled;\n\tindex index.html index.htm;\n\n\tserver_name demo.example.com;\n\tssl_certificate /etc/certificates/live/demo.example.com/fullchain.pem;\n\tssl_certificate_key /etc/certificates/live/demo.example.com/privkey.pem;\n\t\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_prefer_server_ciphers on;\n\tssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";\n\tssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0\n\tssl_session_cache shared:SSL:10m;\n\t#ssl_session_tickets off; # Requires nginx >= 1.5.9\n\tssl_stapling on; # Requires nginx >= 1.3.7\n\tssl_stapling_verify on; # Requires nginx => 1.3.7\n\t#resolver $DNS-IP-1 $DNS-IP-2 valid=300s;\n\t#resolver_timeout 5s;\n\tadd_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";\n\tadd_header X-Frame-Options DENY;\n\tadd_header X-Content-Type-Options nosniff;\n\n\tclient_max_body_size 40M;\n\n\tlocation / {\n   \t\ttry_files $uri /index.html =404;\n\t}\n\n\tlocation ~ /.well-known {\n\t\t allow all;\n\t\t root /usr/share/nginx/html;\n\n\t}\n\n\tlocation  /userdata  {\n            root  /data/public;\n   }\n\n}\n\nserver {\n\tlisten 443 ssl;\n\n\tserver_name api.demo.example.com;\n\tssl_certificate /etc/certificates/live/api.demo.example.com/fullchain.pem; \n\tssl_certificate_key /etc/certificates/live/api.demo.example.com/privkey.pem;\n\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_prefer_server_ciphers on;\n\tssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";\n\tssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0\n\tssl_session_cache shared:SSL:10m;\n\t#ssl_session_tickets off; # Requires nginx >= 1.5.9\n\tssl_stapling on; # Requires nginx >= 1.3.7\n\tssl_stapling_verify on; # Requires nginx => 1.3.7\n\t#resolver $DNS-IP-1 $DNS-IP-2 valid=300s;\n\t#resolver_timeout 5s;\n\tadd_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";\n\tadd_header X-Frame-Options DENY;\n\tadd_header X-Content-Type-Options nosniff;\n\n\tclient_max_body_size 40M;\n\t\n\tlocation / {\n\t\t proxy_pass http://127.0.0.1:4000;\n\t\t proxy_http_version 1.1;\n\t\t proxy_set_header Upgrade $http_upgrade;\n\t\t proxy_set_header Connection \'upgrade\';\n\t\t proxy_set_header Host $host;\n\t\t proxy_cache_bypass $http_upgrade;\n\t}\n\n\tlocation ~ /.well-known {\n\t\t allow all;\n\t\t root /usr/share/nginx/html;\n\t}\n\n}\n\n.... We have more lines of code that isn\'t here for obvious reasons\n\n')])])]),n("p",[e._v("As there is a lot of redundant code, you can see that it becomes difficult to debug whenever something is wrong; We could make this easier  by breaking down the code into smaller blocks that can be imported; To start with, we can start with breaking down the code into three reusable snippets")]),e._v(" "),n("ol",[n("li",[e._v("The ssl configuration")]),e._v(" "),n("li",[e._v("the code for the reverse proxy")]),e._v(" "),n("li",[e._v("the .well-known route")])]),e._v(" "),n("h5",{attrs:{id:"the-ssl-config"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-ssl-config"}},[e._v("#")]),e._v(" The SSL Config")]),e._v(" "),n("p",[e._v("We can see that in the two blocks, the following configuration is common; which is the ssl config for our site. We could place this into the "),n("code",[e._v("/etc/nginx/snippets")]),e._v(" folder and name it "),n("code",[e._v("ssl-config.conf")]),e._v("; this can later be imported into our server blocks;")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('   ssl_certificate /etc/certificates/live/demo.example.com/fullchain.pem;\n\tssl_certificate_key /etc/certificates/live/demo.example.com/privkey.pem;\n\t\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_prefer_server_ciphers on;\n\tssl_ciphers "EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH";\n\tssl_ecdh_curve secp384r1; # Requires nginx >= 1.1.0\n\tssl_session_cache shared:SSL:10m;\n\t#ssl_session_tickets off; # Requires nginx >= 1.5.9\n\tssl_stapling on; # Requires nginx >= 1.3.7\n\tssl_stapling_verify on; # Requires nginx => 1.3.7\n\t#resolver $DNS-IP-1 $DNS-IP-2 valid=300s;\n\t#resolver_timeout 5s;\n\tadd_header Strict-Transport-Security "max-age=63072000; includeSubdomains; preload";\n\tadd_header X-Frame-Options DENY;\n\tadd_header X-Content-Type-Options nosniff;\n\n\tclient_max_body_size 40M;\n')])])]),n("h5",{attrs:{id:"reverse-proxy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reverse-proxy"}},[e._v("#")]),e._v(" Reverse Proxy")]),e._v(" "),n("p",[e._v("The reverse proxy code below is pretty redundant if you are going to be serving multiple applications via reverse proxy, so you could place it into it's own config file. Let's name this "),n("code",[e._v("proxy.conf")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v(" \t\t proxy_http_version 1.1;\n\t\t proxy_set_header Upgrade $http_upgrade;\n\t\t proxy_set_header Connection 'upgrade';\n\t\t proxy_set_header Host $host;\n\t\t proxy_cache_bypass $http_upgrade;\n")])])]),n("p",[e._v("Finally, the "),n("code",[e._v(".well-known")]),e._v(" routes are common in both the blocks and hence would be easy to move into a single config file so that it could be reused again in newer configuration blocks. This is renamed to 'routes.conf'")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("\tlocation ~ /.well-known {\n\t\t allow all;\n\t\t root /usr/share/nginx/html;\n\t}\n\t\n")])])]),n("p",[e._v("We could add even more routes if needed in the future to this block and multiple server blocks could reuse this if needed without having to rewrite the whole blocks again and increasing the lines of code.")]),e._v(" "),n("p",[e._v("Finally, all these lines of code can now be pushed into a single file like the one below.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("server {\n\tlisten 80 default_server;\n\tserver_name demo.example.com;\n\treturn 301 https://demo.example.com$request_uri;\n}\nserver {\n\tlisten 443 ssl http2;\n\troot /home/grant/bluewatertracks/current/client/build/bundled;\n\tindex index.html index.htm;\n\n\tserver_name demo.example.com;\n\tinclude /etc/nginx/snippets/ssl-config.conf; # importing the ssl configurations \n\t\n\tlocation / {\n   \t\ttry_files $uri /index.html =404;\n\t}\n\n\tlocation  /userdata  {\n            root  /data/public;\n   }\n\n\tinclude /etc/nginx/snippets/routes.conf # the well known route is pushed here \n}\n\nserver {\n\tlisten 80 default_server;\n\tserver_name api.demo.example.com;\n\treturn 301 https://api.demo.example.com$request_uri;\n}\n\nserver {\n\tlisten 443 ssl http2;\n\n\tserver_name api.demo.example.com;\n\tinclude /etc/nginx/snippets/ssl-config.conf; # importing the ssl configurations \n\t\n\tlocations / {\n\t\t proxy_pass http://127.0.0.1:4000;\n\t\t include /etc/nginx/snippets/proxy.conf; # reverse proxy header configurations\n\t}\n\t\n\tinclude /etc/nginx/snippets/routes.conf # the well known route is pushed here \n}\n\n")])])]),n("p",[e._v("Using the reusable code, we managed to break down the entire code into smaller more readable code, where in debugging becomes easier because we have smaller lines of code to read.")])])}),[],!1,null,null,null);t.default=r.exports}}]);